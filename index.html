<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="theme-color" content="#ffffff" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <title>geoTrakeo</title>
        <!-- Incluir Leaflet CSS y JS (biblioteca para mapas interactivos) -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
        <style>
            html {
                height: 100svh;
                overflow: hidden;
            }
            body {
                font-family: monospace;
                width: 100vw;
                height: 100svh;
                margin: 0px;
                padding: 0px;
                text-align: center;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }
            .titulo {
                text-align: center;
                background-color: #ffffff;
                margin: 0;
                z-index: 1000;
                padding: 5px;
                font-size: 16px;
            }
            .autor {
                font-size: xx-small;
            }
            button {
                background-color: #d1d1d1;
                border: none;
                color: black;
                padding: 8px;
                text-align: center;
                text-decoration: none;
                display: inline-block;
                cursor: pointer;
                font-family: monospace;
            }
            button:disabled {
                background-color: #ffffff;
                color: #d1d1d1;
                cursor: not-allowed;
            }
            #clearBtn {
                background-color: #ffffff;
            }
            #downloadBtn {
                background-color: #ffffff;
            }
            .controls {
                position: absolute;
                bottom: 30px;
                left: 50%;
                translate: -50%;
                display: grid;
                grid-template-columns: 1fr 1fr;
                z-index: 1000;
                width: 90vw;
                max-width: 400px;
                overflow: hidden;
                gap: 2px;
            }
            #status {
                grid-column: 1 /3;
                background-color: #ffffff;
                padding: 4px;
            }
            .intervalo {
                display: flex;
                align-items: center;
                background-color: #ffffff;
            }
            .instrucciones {
                background-color: #ffffff;
                padding: 4px;
                font-size: smaller;
            }
            #intervalInput {
                margin-right: 10px;
                text-align: center;
                padding: 0;
            }
            .container {
                display: flex;
                flex-direction: column;
                gap: 20px;
            }
            .panel {
                position: absolute;
                top: 115px;
                right: 10px;
                z-index: 1000;
                font-size: xx-small;
                pointer-events: none;
            }
            #map {
                width: 100%;
                flex: 1;
                background-color: #f0f0f0;
                margin: 0px;
            }
            #coordinates {
                height: 300px;
                overflow-y: auto;
                text-align: left;
                pointer-events: none;
            }
            .coordinate-entry {
                margin-bottom: 5px;
                padding: 5px;
                background-color: #f9f9f900;
                pointer-events: none;
            }
            .error {
                color: red;
            }
            .legend {
                padding: 5px;
                background: #ffffff;
                display: flex;
                flex-direction: column;
                gap: 5px;
            }
            .legend div {
                display: flex;
                gap: 6px;
                align-items: center;
                font-size: smaller;
            }
            .legend i {
                width: 14px;
                height: 14px;
                float: left;
                border-radius: 50%;
            }
            /* Estilo personalizado para tooltip sin fondo */
            .custom-tooltip {
                background: transparent;
                border: none;
                box-shadow: none;
                font-weight: bold;
                color: black;
                font-size: 11px;
            }
            .custom-tooltip::before {
                display: none;
            }
            p {
                margin: 0;
                padding: 0;
            }
            .background-indicator {
                display: inline-block;
                width: 8px;
                height: 8px;
                border-radius: 50%;
                margin-right: 4px;
                background-color: #4caf50;
            }
            .background-active {
                background-color: #4caf50;
            }
            .background-inactive {
                background-color: #cccccc;
            }
            .status-indicator {
                position: absolute;
                top: 10px;
                right: 10px;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                z-index: 1000;
                background-color: #4caf50;
                box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
                cursor: pointer;
            }
            .status-good {
                background-color: #4caf50; /* verde */
            }
            .status-warning {
                background-color: #ff9800; /* naranja */
            }
            .status-error {
                background-color: #f44336; /* rojo */
            }
            .status-info {
                position: absolute;
                top: 30px;
                right: 10px;
                background-color: white;
                padding: 10px;
                border-radius: 4px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
                font-size: xx-small;
                z-index: 1000;
                max-width: 200px;
                text-align: left;
                display: none;
            }
        </style>
    </head>
    <body>
        <h1 class="titulo">geoTrakeo <span class="autor">by ei</span></h1>

        <!-- Añadir estas dos líneas -->
        <div class="status-indicator"></div>
        <div class="status-info"></div>

        <div id="map"></div>

        <div class="controls">
            <div id="status"></div>

            <p class="instrucciones">Configura el intervalo y haz clic en iniciar para recopilar coordenadas.</p>
            <div class="intervalo">
                <label for="intervalInput">Intervalo (seg): </label>
                <input type="number" id="intervalInput" min="1" max="120" value="20" />
            </div>

            <button id="startBtn">Iniciar seguimiento</button>
            <button id="stopBtn" disabled>Detener seguimiento</button>

            <button id="clearBtn">Borrar registros</button>
            <button id="downloadBtn">Descargar recorrido</button>
        </div>

        <div class="panel">
            <div id="coordinates"></div>
        </div>

        <!-- Incluir Leaflet JS -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
        <script>
            // Elementos del DOM
            const startBtn = document.getElementById("startBtn");
            const stopBtn = document.getElementById("stopBtn");
            const clearBtn = document.getElementById("clearBtn");
            const downloadBtn = document.getElementById("downloadBtn");
            const intervalInput = document.getElementById("intervalInput");
            const status = document.getElementById("status");
            const coordinates = document.getElementById("coordinates");
            const backgroundNote = document.querySelector(".background-note");
            const statusIndicator = document.querySelector(".status-indicator");
            const statusInfo = document.querySelector(".status-info");

            // Variables de control
            let trackingInterval;
            let entriesCount = 0;
            let coordinatesData = [];
            let isTracking = false;
            let trackingWorker = null;
            let lastPositionTime = 0;

            // Nombre del almacenamiento para guardar datos
            const STORAGE_KEY = "geoTrackerData";

            // Comprobar soporte para APIs necesarias
            const hasServiceWorkerSupport = "serviceWorker" in navigator;
            const hasWakeLockSupport = "wakeLock" in navigator;
            let wakeLock = null;

            // Inicializar el mapa de Leaflet
            let map = L.map("map").setView([0, 0], 2);
            let routeLine = L.polyline([], { color: "#292929", weight: 4 });
            let markersLayer = L.layerGroup();
            let firstLoad = true;

            // Añadir la capa de OpenStreetMap
            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            }).addTo(map);

            // Crear leyenda
            let legend = L.control({ position: "topright" });
            legend.onAdd = function (map) {
                let div = L.DomUtil.create("div", "legend");
                div.innerHTML = `
                <div><i style="background: #858585"></i> Puntos anteriores<br></div>
                <div><i style="background: #292929"></i> Punto actual<br></div>
                <div><i style="background: #292929; height: 4px; width: 14px; border-radius: 0"></i> Recorrido</div>
            `;
                return div;
            };
            legend.addTo(map);

            // Actualizar indicador de estado de seguimiento
            function updateTrackingStatus(status = "good", message = "") {
                // Eliminar clases existentes
                statusIndicator.classList.remove("status-good", "status-warning", "status-error");

                // Determinar mensaje según el estado
                let statusText = "";

                // Añadir la clase apropiada según el estado
                if (status === "good") {
                    statusIndicator.classList.add("status-good");
                    statusText = message || "Seguimiento funcionando correctamente";
                } else if (status === "warning") {
                    statusIndicator.classList.add("status-warning");
                    statusText = message || "Seguimiento funcionando con dificultades";
                } else if (status === "error") {
                    statusIndicator.classList.add("status-error");
                    statusText = message || "Error en el seguimiento";
                }

                // Actualizar contenido del div de información
                statusInfo.innerHTML = statusText;
                // Mantener atributo title para navegadores de escritorio
                statusIndicator.title = statusText;
            }

            // Manejar clic en el indicador de estado
            statusIndicator.addEventListener("click", function (e) {
                e.stopPropagation(); // Evitar que el clic llegue al mapa
                statusInfo.style.display = statusInfo.style.display === "block" ? "none" : "block";
            });

            // Cerrar el panel informativo al hacer clic en cualquier otra parte
            document.addEventListener("click", function (e) {
                if (e.target !== statusIndicator && e.target !== statusInfo) {
                    statusInfo.style.display = "none";
                }
            });

            // Cargar datos guardados al iniciar y verificar si había un seguimiento activo
            window.onload = function () {
                loadSavedData();
                updateMap();
                updateTrackingStatus("good");

                // Comprobar si hay un seguimiento activo desde una sesión anterior
                const wasTracking = localStorage.getItem("trackingActive") === "true";
                if (wasTracking) {
                    const interval = parseInt(localStorage.getItem("trackingInterval") || "20");
                    intervalInput.value = interval;

                    // Informar al usuario
                    status.innerHTML = "<p>Recuperando seguimiento de sesión anterior...</p>";

                    // Iniciar el seguimiento nuevamente
                    setTimeout(() => {
                        startTrackingOptimized();
                    }, 1000);
                }

                // Mostrar información sobre seguimiento en segundo plano
                updateBackgroundStatus();
            };

            // Actualizar indicador de seguimiento en segundo plano
            function updateBackgroundStatus() {
                const hasBackgroundSupport = hasWakeLockSupport || hasServiceWorkerSupport;
                backgroundNote.innerHTML = hasBackgroundSupport
                    ? '<span class="background-indicator background-active"></span> Seguimiento continuo disponible'
                    : '<span class="background-indicator background-inactive"></span> Seguimiento limitado';
            }

            // Función para obtener la ubicación actual

            // Función para solicitar WakeLock (mantener pantalla activa)
            async function requestWakeLock() {
                if (!hasWakeLockSupport) return;

                try {
                    wakeLock = await navigator.wakeLock.request("screen");
                    wakeLock.addEventListener("release", () => {
                        console.log("WakeLock fue liberado");
                        // Intentar adquirirlo nuevamente si seguimos en seguimiento
                        if (isTracking) {
                            requestWakeLock();
                        }
                    });
                    console.log("WakeLock activado");
                } catch (err) {
                    console.error(`No se pudo obtener WakeLock: ${err.name}, ${err.message}`);
                }
            }

            // Función para manejar cambios de visibilidad de la página
            function handleVisibilityChange() {
                if (document.visibilityState === "visible" && isTracking) {
                    // La página volvió a ser visible
                    console.log("Página visible de nuevo, verificando posiciones perdidas");

                    const lastCheck = parseInt(localStorage.getItem("trackingLastCheck") || "0");
                    const interval = parseInt(localStorage.getItem("trackingInterval") || "20");
                    const now = Date.now();

                    // Si han pasado más de dos intervalos desde la última verificación
                    if (now - lastCheck > interval * 2000) {
                        console.log("Recuperando posición después de inactividad");
                        getCurrentPositionOptimized();
                        updateTrackingStatus("warning", "Han pasado " + Math.round((now - lastCheck) / 1000) + "s sin actualizar la posición. Recuperando...");
                    }

                    // Actualizar la hora del último chequeo
                    localStorage.setItem("trackingLastCheck", now.toString());

                    // Reactivar el WakeLock si es necesario
                    if (hasWakeLockSupport && !wakeLock) {
                        requestWakeLock();
                    }
                }
            }

            // Configurar seguimiento en segundo plano
            function setupBackgroundTracking(interval) {
                // Verificar si el navegador soporta trabajadores en segundo plano
                if (window.Worker) {
                    try {
                        // Crear un Blob con el código del worker
                        const workerCode = `
                            let trackingInterval;
                            
                            self.onmessage = function(e) {
                                if (e.data.command === 'start') {
                                    const interval = e.data.interval;
                                    trackingInterval = setInterval(() => {
                                        self.postMessage({type: 'requestPosition'});
                                    }, interval * 1000);
                                    console.log('Worker iniciado con intervalo: ' + interval + 's');
                                } else if (e.data.command === 'stop') {
                                    clearInterval(trackingInterval);
                                    console.log('Worker detenido');
                                    self.close();
                                }
                            };
                        `;

                        // Crear una URL para el Blob
                        const workerBlob = new Blob([workerCode], { type: "application/javascript" });
                        const workerUrl = URL.createObjectURL(workerBlob);

                        // Crear el worker
                        trackingWorker = new Worker(workerUrl);

                        // Configurar el listener para mensajes del worker
                        trackingWorker.onmessage = function (e) {
                            if (e.data.type === "requestPosition") {
                                // El worker solicita una actualización de posición
                                getCurrentPositionOptimized();
                            }
                        };

                        // Iniciar el worker
                        trackingWorker.postMessage({
                            command: "start",
                            interval: interval,
                        });

                        console.log("Worker de seguimiento iniciado");
                    } catch (err) {
                        console.error("Error al iniciar worker: ", err);
                    }
                }
            }

            // Función para iniciar el seguimiento
            // --- Código para prevenir duplicados y mejorar rendimiento ---

            // 1. Variables para controlar duplicados
            let lastPosition = null;
            let isGettingPosition = false;
            let positionRequestCount = 0;
            let renderTimeLog = [];

            // 2. Función optimizada para obtener posición
            function getCurrentPositionOptimized() {
                // Si ya está en proceso de obtener posición, no iniciar otra solicitud
                if (isGettingPosition) {
                    console.log("Solicitud de posición ignorada: ya hay una en proceso");
                    return;
                }

                isGettingPosition = true;
                positionRequestCount++;

                const requestStartTime = performance.now();
                console.log(`Iniciando solicitud #${positionRequestCount} en: ${new Date().toLocaleTimeString()}`);

                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const requestEndTime = performance.now();
                            console.log(`Solicitud #${positionRequestCount} completada en: ${Math.round(requestEndTime - requestStartTime)}ms`);

                            const latitude = position.coords.latitude;
                            const longitude = position.coords.longitude;

                            // Comprobar si la posición es diferente de la última (con cierta tolerancia)
                            const isDifferentPosition =
                                !lastPosition || Math.abs(latitude - lastPosition.lat) > 0.0000001 || Math.abs(longitude - lastPosition.lng) > 0.0000001;

                            if (isDifferentPosition) {
                                // Registrar el tiempo antes de procesar la posición
                                const renderStartTime = performance.now();

                                // Guardar esta posición como la última
                                lastPosition = { lat: latitude, lng: longitude };

                                // Procesar la nueva posición
                                const timestamp = new Date();

                                // Calcular la distancia desde el punto anterior si existe
                                let distanceFromLast = 0;
                                if (coordinatesData.length > 0) {
                                    const lastPoint = coordinatesData[coordinatesData.length - 1];
                                    distanceFromLast = calculateDistance(lastPoint.coords.latitude, lastPoint.coords.longitude, latitude, longitude);
                                }

                                // Guardar datos para GeoJSON
                                const pointData = {
                                    id: ++entriesCount,
                                    timestamp: timestamp.toISOString(),
                                    coords: {
                                        latitude: latitude,
                                        longitude: longitude,
                                        accuracy: position.coords.accuracy || 0,
                                    },
                                    distanceFromLast: distanceFromLast,
                                };
                                coordinatesData.push(pointData);

                                // Actualizar UI con optimización
                                updateUIWithNewPoint(pointData);

                                // Medir tiempo de renderizado
                                const renderEndTime = performance.now();
                                const renderTime = Math.round(renderEndTime - renderStartTime);
                                renderTimeLog.push({
                                    pointId: entriesCount,
                                    renderTime: renderTime,
                                    totalPoints: coordinatesData.length,
                                });

                                // Registrar en consola
                                console.log(`Punto #${entriesCount} añadido. Tiempo de renderizado: ${renderTime}ms`);
                                console.log(`Distancia desde el punto anterior: ${distanceFromLast.toFixed(2)}m`);

                                // Mostrar estadísticas cada 5 puntos
                                if (entriesCount % 5 === 0) {
                                    logPerformanceStats();
                                }
                            } else {
                                console.log("Posición ignorada: es idéntica a la anterior");
                            }

                            // Actualizar hora del último check
                            lastPositionTime = Date.now();
                            localStorage.setItem("trackingLastCheck", lastPositionTime.toString());

                            // Guardar datos en almacenamiento local
                            saveData();
                            updateTrackingStatus("good");

                            // Marcar como completada la solicitud
                            isGettingPosition = false;
                        },
                        (error) => {
                            console.error(`Error de geolocalización: ${error.code} - ${error.message}`);

                            const errorMsg = document.createElement("div");
                            errorMsg.className = "error";

                            switch (error.code) {
                                case error.PERMISSION_DENIED:
                                    errorMsg.textContent = "Usuario denegó la solicitud de geolocalización.";
                                    break;
                                case error.POSITION_UNAVAILABLE:
                                    errorMsg.textContent = "Información de ubicación no disponible.";
                                    break;
                                case error.TIMEOUT:
                                    errorMsg.textContent = "Tiempo de espera agotado para obtener ubicación.";
                                    break;
                                case error.UNKNOWN_ERROR:
                                    errorMsg.textContent = "Error desconocido.";
                                    break;
                            }

                            status.innerHTML = "";
                            status.appendChild(errorMsg);
                            updateTrackingStatus("error", "No se pudo obtener la ubicación: " + errorMsg.textContent);

                            // Marcar como completada la solicitud
                            isGettingPosition = false;
                        },
                        {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 0,
                        }
                    );
                } else {
                    status.innerHTML = "<div class='error'>La geolocalización no es compatible con este navegador.</div>";
                    updateTrackingStatus("error", "La geolocalización no es compatible con este navegador");
                    stopTracking();
                    isGettingPosition = false;
                }
            }

            // 3. Función para optimizar la actualización de UI
            function updateUIWithNewPoint(pointData) {
                // Crear entrada para el panel de coordenadas sin recargar todo
                const entry = document.createElement("div");
                entry.className = "coordinate-entry";
                const displayTime = new Date(pointData.timestamp).toLocaleTimeString();
                entry.innerHTML = `
        <strong>${pointData.id}. ${displayTime}</strong><br>
        Lat: ${pointData.coords.latitude}<br>
        Long: ${pointData.coords.longitude}
    `;

                // Si hay contenido inicial y es el primer elemento, eliminarlo
                if (pointData.id === 1 && coordinates.firstChild && coordinates.firstChild.tagName === "P") {
                    coordinates.innerHTML = "";
                }

                // Agregar la nueva entrada al principio
                coordinates.insertBefore(entry, coordinates.firstChild);

                // Limitar entradas visibles para mejorar rendimiento (opcional)
                const maxEntries = 20;
                while (coordinates.children.length > maxEntries) {
                    coordinates.removeChild(coordinates.lastChild);
                }

                // Actualizar solo lo necesario del mapa
                updateMapWithNewPoint(pointData);
            }

            // 4. Función para actualizar el mapa de forma optimizada
            function updateMapWithNewPoint(newPoint) {
                // Obtener coordenadas del nuevo punto
                const latlng = [newPoint.coords.latitude, newPoint.coords.longitude];

                // Añadir el punto a la polilínea sin recrearla completamente
                routeLine.addLatLng(latlng);

                // Crear y añadir solo el nuevo marcador
                const marker = L.circleMarker(latlng, {
                    radius: 8,
                    fillColor: "#292929", // El último punto siempre es actual
                    color: "#000",
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8,
                });

                // Añadir información al marcador
                const localTime = new Date(newPoint.timestamp).toLocaleTimeString();
                marker.bindPopup(`
        <strong>Punto #${newPoint.id}</strong><br>
        Hora: ${localTime}<br>
        Latitud: ${newPoint.coords.latitude}<br>
        Longitud: ${newPoint.coords.longitude}<br>
        ${newPoint.coords.accuracy ? `Precisión: ${newPoint.coords.accuracy} metros` : ""}
        ${newPoint.distanceFromLast ? `<br>Distancia: ${newPoint.distanceFromLast.toFixed(2)}m` : ""}
    `);

                // Añadir etiqueta con el número
                marker.bindTooltip(newPoint.id.toString(), {
                    permanent: true,
                    direction: "right",
                    offset: [5, -5],
                    className: "custom-tooltip",
                });

                // Añadir el marcador actual
                markersLayer.addLayer(marker);

                // Si hay más de un punto, cambiar el color del punto anterior a gris
                if (coordinatesData.length > 1) {
                    // Esto requiere que almacenemos las referencias a los marcadores
                    // o que los busquemos en la capa. Por simplicidad, vamos a recrear los marcadores.
                    updatePreviousMarkers();
                }

                // Si estamos rastreando, centrar en el nuevo punto
                if (isTracking) {
                    map.panTo(latlng);
                }
            }

            // 5. Actualizar marcadores anteriores
            function updatePreviousMarkers() {
                // Si hay demasiados puntos, limitar cuántos se muestran para mejorar rendimiento
                const maxVisiblePoints = 50; // Ajustar según rendimiento
                const startIndex = Math.max(0, coordinatesData.length - maxVisiblePoints);

                // Recrear marcadores (no es lo más eficiente, pero funciona con la estructura actual)
                markersLayer.clearLayers();

                for (let i = startIndex; i < coordinatesData.length; i++) {
                    const point = coordinatesData[i];
                    const isLatestPoint = i === coordinatesData.length - 1;

                    // Color del marcador basado en si es el último punto o no
                    const markerColor = isLatestPoint ? "#292929" : "#858585";

                    // Crear marcador
                    const marker = L.circleMarker([point.coords.latitude, point.coords.longitude], {
                        radius: 8,
                        fillColor: markerColor,
                        color: "#000",
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8,
                    });

                    // Añadir información al marcador
                    const localTime = new Date(point.timestamp).toLocaleTimeString();
                    marker.bindPopup(`
            <strong>Punto #${point.id}</strong><br>
            Hora: ${localTime}<br>
            Latitud: ${point.coords.latitude}<br>
            Longitud: ${point.coords.longitude}<br>
            ${point.coords.accuracy ? `Precisión: ${point.coords.accuracy} metros` : ""}
            ${point.distanceFromLast ? `<br>Distancia: ${point.distanceFromLast.toFixed(2)}m` : ""}
        `);

                    // Añadir etiqueta con el número
                    marker.bindTooltip(point.id.toString(), {
                        permanent: true,
                        direction: "right",
                        offset: [5, -5],
                        className: "custom-tooltip",
                    });

                    // Añadir el marcador a la capa
                    markersLayer.addLayer(marker);
                }
            }

            // 6. Función para calcular distancia entre puntos (Haversine)
            function calculateDistance(lat1, lon1, lat2, lon2) {
                const R = 6371e3; // Radio de la tierra en metros
                const φ1 = (lat1 * Math.PI) / 180;
                const φ2 = (lat2 * Math.PI) / 180;
                const Δφ = ((lat2 - lat1) * Math.PI) / 180;
                const Δλ = ((lon2 - lon1) * Math.PI) / 180;

                const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                return R * c; // Distancia en metros
            }

            // 7. Función para mostrar estadísticas de rendimiento
            function logPerformanceStats() {
                if (renderTimeLog.length === 0) return;

                // Calcular estadísticas
                const avgRenderTime = renderTimeLog.reduce((sum, entry) => sum + entry.renderTime, 0) / renderTimeLog.length;
                const maxRenderTime = Math.max(...renderTimeLog.map((entry) => entry.renderTime));

                console.group("Estadísticas de rendimiento");
                console.log(`Tiempo medio de renderizado: ${avgRenderTime.toFixed(2)}ms`);
                console.log(`Tiempo máximo de renderizado: ${maxRenderTime}ms`);
                console.log(`Total de puntos: ${coordinatesData.length}`);
                console.log(`Solicitudes de posición: ${positionRequestCount}`);

                // Encontrar puntos problemáticos
                const slowRenders = renderTimeLog.filter((entry) => entry.renderTime > avgRenderTime * 2);
                if (slowRenders.length > 0) {
                    console.log(`Puntos con renderizado lento (>${avgRenderTime * 2}ms):`, slowRenders);
                }

                console.groupEnd();
            }

            // 8. Función para limpiar datos antiguos de rendimiento
            function clearPerformanceData() {
                renderTimeLog = [];
                positionRequestCount = 0;
            }

            // 9. Al iniciar seguimiento, usar esta función optimizada
            function startTrackingOptimized() {
                // Comprobar si el navegador soporta geolocalización
                if (!navigator.geolocation) {
                    status.innerHTML = "<div class='error'>La geolocalización no es compatible con este navegador.</div>";
                    return;
                }

                // Obtener intervalo de actualización
                const interval = parseInt(intervalInput.value) || 20;
                if (interval < 1 || interval > 120) {
                    status.innerHTML = "<div class='error'>El intervalo debe estar entre 1 y 120 segundos.</div>";
                    return;
                }

                // Limpiar datos de rendimiento
                clearPerformanceData();

                // Cambiar estado de botones
                startBtn.disabled = true;
                stopBtn.disabled = false;
                clearBtn.disabled = true;
                downloadBtn.disabled = true;
                intervalInput.disabled = true;
                isTracking = true;

                // Mostrar mensaje de estado
                status.innerHTML = `<p>Seguimiento activo (cada ${interval} segundos)...</p>`;
                updateTrackingStatus("good");
                // Solicitar WakeLock para mantener la pantalla activa (si está disponible)
                if (hasWakeLockSupport) {
                    requestWakeLock();
                }

                // Registrar para notificaciones en segundo plano (si está disponible)
                if (hasServiceWorkerSupport && "Notification" in window) {
                    Notification.requestPermission();
                }

                // Obtener posición inicial con la función optimizada
                getCurrentPositionOptimized();

                // Usar localStorage para almacenar la hora de inicio y el intervalo
                localStorage.setItem("trackingActive", "true");
                localStorage.setItem("trackingInterval", interval.toString());
                localStorage.setItem("trackingLastCheck", Date.now().toString());

                // Crear un worker para seguimiento en segundo plano
                setupBackgroundTracking(interval);

                // Configurar intervalo para obtener posición (como respaldo)
                // Asegurarse de que usamos la función optimizada
                trackingInterval = setInterval(getCurrentPositionOptimized, interval * 1000);

                // Configurar evento de visibilidad para detectar cuando la página vuelve a estar visible
                document.addEventListener("visibilitychange", handleVisibilityChange);

                // Registrar evento para cuando la aplicación se cierra
                window.addEventListener("beforeunload", function () {
                    if (isTracking) {
                        localStorage.setItem("trackingActive", "true");
                        localStorage.setItem("trackingLastCheck", Date.now().toString());
                    }
                });

                // Imprimir información de diagnóstico
                console.log(`Seguimiento iniciado con intervalo de ${interval}s`);
                console.log(`Soporte de WakeLock: ${hasWakeLockSupport}`);
                console.log(`Soporte de Service Worker: ${hasServiceWorkerSupport}`);
            }

            // Para implementar estas funciones, reemplaza las llamadas a getCurrentPosition() con
            // getCurrentPositionOptimized() y startTracking() con startTrackingOptimized()

            // Función para detener el seguimiento
            function stopTracking() {
                // Detener intervalo
                clearInterval(trackingInterval);

                // Cambiar estado de botones
                startBtn.disabled = false;
                stopBtn.disabled = true;
                clearBtn.disabled = false;
                downloadBtn.disabled = false;
                intervalInput.disabled = false;
                isTracking = false;

                // Mostrar mensaje de estado
                status.innerHTML = "<p>Seguimiento detenido.</p>";

                // Liberar WakeLock si existe
                if (wakeLock) {
                    wakeLock.release().then(() => {
                        wakeLock = null;
                        console.log("WakeLock liberado");
                    });
                }

                // Detener el worker si existe
                if (trackingWorker) {
                    trackingWorker.postMessage({ command: "stop" });
                    trackingWorker = null;
                }

                // Eliminar marcadores de seguimiento en localStorage
                localStorage.removeItem("trackingActive");
                localStorage.removeItem("trackingInterval");
                localStorage.removeItem("trackingLastCheck");

                // Eliminar event listeners
                document.removeEventListener("visibilitychange", handleVisibilityChange);
            }

            // Función para borrar todos los registros
            function clearData() {
                coordinates.innerHTML = "";
                entriesCount = 0;
                coordinatesData = [];
                saveData();
                status.innerHTML = "<p>Todos los registros han sido borrados.</p>";
                updateTrackingStatus("good");
                // Limpiar el mapa
                markersLayer.clearLayers();
                routeLine.setLatLngs([]);
                map.addLayer(routeLine);
                map.setView([0, 0], 2);
            }

            // Función para descargar datos en formato GeoJSON
            function downloadGeoJSON() {
                if (coordinatesData.length === 0) {
                    status.innerHTML = "<div class='error'>No hay datos para descargar.</div>";
                    return;
                }

                // Crear objeto GeoJSON con la polilínea como elemento principal
                const geoJSON = {
                    type: "FeatureCollection",
                    features: [
                        // LineString para el recorrido completo (polilínea principal)
                        {
                            type: "Feature",
                            properties: {
                                name: "Recorrido completo",
                                description: "Trayecto registrado con aplicación de seguimiento GPS",
                                startTime: coordinatesData[0].timestamp,
                                endTime: coordinatesData[coordinatesData.length - 1].timestamp,
                                pointsCount: coordinatesData.length,
                            },
                            geometry: {
                                type: "LineString",
                                coordinates: coordinatesData.map((p) => [p.coords.longitude, p.coords.latitude]),
                            },
                        },
                    ],
                };

                // Crear archivo para descargar
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(geoJSON, null, 2));
                const downloadAnchor = document.createElement("a");
                downloadAnchor.setAttribute("href", dataStr);
                downloadAnchor.setAttribute("download", `geo_tracking_${new Date().toISOString().slice(0, 10)}.geojson`);
                document.body.appendChild(downloadAnchor);
                downloadAnchor.click();
                downloadAnchor.remove();

                status.innerHTML = "<p>Archivo GeoJSON descargado.</p>";
            }

            // Función para guardar datos en localStorage
            function saveData() {
                try {
                    localStorage.setItem(
                        STORAGE_KEY,
                        JSON.stringify({
                            count: entriesCount,
                            data: coordinatesData,
                        })
                    );
                } catch (e) {
                    console.error("Error al guardar datos:", e);
                    status.innerHTML += "<div class='error'>No se pudieron guardar los datos localmente.</div>";
                }
            }

            // Función para cargar datos guardados
            function loadSavedData() {
                try {
                    const savedData = localStorage.getItem(STORAGE_KEY);
                    if (savedData) {
                        const parsedData = JSON.parse(savedData);
                        coordinatesData = parsedData.data || [];
                        entriesCount = parsedData.count || 0;

                        if (coordinatesData.length > 0) {
                            // Limpiar el contenedor
                            coordinates.innerHTML = "";

                            // Mostrar datos guardados
                            coordinatesData
                                .slice()
                                .reverse()
                                .forEach((point) => {
                                    const entry = document.createElement("div");
                                    entry.className = "coordinate-entry";
                                    const localTime = new Date(point.timestamp).toLocaleTimeString();
                                    entry.innerHTML = `
                                <strong>${point.id}. ${localTime}</strong><br>
                                Lat: ${point.coords.latitude}<br>
                                Long: ${point.coords.longitude}
                            `;
                                    coordinates.appendChild(entry);
                                });

                            status.innerHTML = `<p>Se cargaron ${coordinatesData.length} registros guardados.</p>`;
                        }
                    }
                } catch (e) {
                    console.error("Error al cargar datos:", e);
                    status.innerHTML = "<div class='error'>Error al cargar datos guardados.</div>";
                }
            }

            // Función para actualizar el mapa
            function updateMap() {
                // Limpiar las capas anteriores
                markersLayer.clearLayers();
                routeLine.setLatLngs([]);

                if (coordinatesData.length === 0) {
                    return;
                }

                // Crear array de puntos para la línea
                const routePoints = coordinatesData.map((point) => [point.coords.latitude, point.coords.longitude]);

                // Actualizar la línea de ruta
                routeLine.setLatLngs(routePoints);
                map.addLayer(routeLine);

                // Añadir marcadores para cada punto
                coordinatesData.forEach((point, index) => {
                    // Determinar si es el punto más reciente
                    const isLatestPoint = index === coordinatesData.length - 1;

                    // Color del marcador basado en si es el último punto o no
                    const markerColor = isLatestPoint ? "#292929" : "#858585";

                    // Crear marcador con círculo personalizado
                    const marker = L.circleMarker([point.coords.latitude, point.coords.longitude], {
                        radius: 8,
                        fillColor: markerColor,
                        color: "#000",
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8,
                    });

                    // Añadir información al marcador
                    const localTime = new Date(point.timestamp).toLocaleTimeString();
                    marker.bindPopup(`
                    <strong>Punto #${point.id}</strong><br>
                    Hora: ${localTime}<br>
                    Latitud: ${point.coords.latitude}<br>
                    Longitud: ${point.coords.longitude}<br>
                `);

                    // Añadir etiqueta con el número del punto a la derecha
                    marker.bindTooltip(point.id.toString(), {
                        permanent: true,
                        direction: "right", // Colocar a la derecha
                        offset: [5, -5], // Ajustar posición (x, y)
                        className: "custom-tooltip", // Clase personalizada
                    });

                    // Añadir el marcador a la capa de marcadores
                    markersLayer.addLayer(marker);
                });

                // Añadir capa de marcadores al mapa
                map.addLayer(markersLayer);

                // Al cargar por primera vez o cuando hay nuevos datos, hacer zoom al recorrido
                if (firstLoad || coordinatesData.length <= 1) {
                    // Si solo hay un punto, hacer zoom a ese punto
                    if (coordinatesData.length === 1) {
                        const point = coordinatesData[0];
                        map.setView([point.coords.latitude, point.coords.longitude], 17);
                    } else {
                        // Si hay múltiples puntos, ajustar la vista para incluir todos
                        const bounds = L.latLngBounds(routePoints);
                        map.fitBounds(bounds, { padding: [50, 50] });
                    }
                    firstLoad = false;
                } else if (isTracking) {
                    // Para actualizaciones posteriores durante el seguimiento, centrar en el punto más reciente
                    const latestPoint = coordinatesData[coordinatesData.length - 1];
                    map.panTo([latestPoint.coords.latitude, latestPoint.coords.longitude]);
                }
            }

            // Asignar eventos a botones
            startBtn.addEventListener("click", startTrackingOptimized);
            stopBtn.addEventListener("click", stopTracking);
            clearBtn.addEventListener("click", clearData);
            downloadBtn.addEventListener("click", downloadGeoJSON);

            // Actualizar tamaño del mapa cuando se redimensione la ventana
            window.addEventListener("resize", function () {
                map.invalidateSize();
            });
        </script>
    </body>
</html>
