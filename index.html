<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="theme-color" content="#ffffff">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <title>geoTrakeo</title>
        <!-- Incluir Leaflet CSS y JS (biblioteca para mapas interactivos) -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
        <style>
            html{
                height: 100svh;
                overflow: hidden;
            }
            body {
                font-family:monospace;
                width: 100vw;
                height: 100svh;
                margin: 0px;
                padding: 0px;
                text-align: center;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }
            .titulo {
                text-align: center;
                background-color: #ffffff;
                margin: 0;
                z-index: 1000;
                padding: 5px;
                font-size: 16px;
            }
            .autor {
                font-size: xx-small;
            }
            button {
                background-color: #d1d1d1;
                border: none;
                color: black;
                padding: 8px;
                text-align: center;
                text-decoration: none;
                display: inline-block;
                cursor: pointer;
                font-family:monospace;
            }
            button:disabled {
                background-color: #ffffff;
                color: #d1d1d1;
                cursor: not-allowed;
            }
            #clearBtn {
                background-color: #ffffff;
            }
            #downloadBtn {
                background-color: #ffffff;
            }
            .controls {
                position: absolute;
                bottom: 30px;
                left: 50%;
                translate: -50%;
                display: grid;
                grid-template-columns: 1fr 1fr;
                z-index: 1000;
                width: 90vw;
                max-width: 400px;
                overflow: hidden;
                gap: 2px;
            }
            #status {
                grid-column: 1 /3;
                background-color: #ffffff;
                padding: 4px;
            }
            .intervalo{
                display: flex;
                align-items: center;
                background-color: #ffffff;
            }
            .instrucciones{
                background-color: #ffffff;
                padding: 4px;
                font-size: smaller;
            }
            #intervalInput {
                margin-right: 10px;
                text-align: center;
                padding: 0;
            }
            .container {
                display: flex;
                flex-direction: column;
                gap: 20px;
            }
            .panel {
                position: absolute;
                top: 115px;
                right: 10px;
                z-index: 1000;
                font-size: xx-small;
                pointer-events: none;
            }
            #map {
                width: 100%;
                flex: 1;
                background-color: #f0f0f0;
                margin: 0px;
            }
            #coordinates {
                height: 300px;
                overflow-y: auto;
                text-align: left;
                pointer-events: none;
            }
            .coordinate-entry {
                margin-bottom: 5px;
                padding: 5px;
                background-color: #f9f9f900;
                pointer-events: none;
            }
            .error {
                color: red;
            }
            .legend {
                padding: 5px;
                background: #ffffff;
                display: flex;
                flex-direction: column;
                gap: 5px;
            }
            .legend div {
                display: flex;
                gap: 6px;
                align-items: center;
                font-size: smaller;
            }
            .legend i {
                width: 14px;
                height: 14px;
                float: left;
                border-radius: 50%;
            }
            /* Estilo personalizado para tooltip sin fondo */
            .custom-tooltip {
                background: transparent;
                border: none;
                box-shadow: none;
                font-weight: bold;
                color: black;
                font-size: 11px;
            }
            .custom-tooltip::before {
                display: none;
            }
            p {
                margin: 0;
                padding: 0;
            }
            .status-indicator {
                position: absolute;
                top: 10px;
                right: 10px;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                z-index: 1000;
                background-color: #4CAF50;
                box-shadow: 0 0 3px rgba(0,0,0,0.3);
                cursor: pointer;
            }
            .status-good {
                background-color: #4CAF50; /* verde */
            }
            .status-warning {
                background-color: #FF9800; /* naranja */
            }
            .status-error {
                background-color: #F44336; /* rojo */
            }
            .status-info {
                position: absolute;
                top: 40px;
                right: 10px;
                background-color: black;
                color: #4CAF50;
                padding: 10px;
                font-size: xx-small;
                z-index: 2000;
                max-width: 200px;
                text-align: left;
                display: none;
            }
        </style>
    </head>
    <body>
        <h1 class="titulo">geoTrakeo <span class="autor">by ei</span></h1>
        
        <div class="status-indicator"></div>
        <div class="status-info"></div>
        
        <div id="map"></div>

        <div class="controls">
            <div id="status"></div>

            <p class="instrucciones">Configura el intervalo y haz clic en iniciar para recopilar coordenadas.</p>
            <div class="intervalo">
                <label for="intervalInput">Intervalo (seg): </label>
                <input type="number" id="intervalInput" min="1" max="120" value="20" />
            </div>

            <button id="startBtn">Iniciar seguimiento</button>
            <button id="stopBtn" disabled>Detener seguimiento</button>

            <button id="clearBtn">Borrar registros</button>
            <button id="downloadBtn">Descargar recorrido</button>
        </div>

        <div class="panel">
            <div id="coordinates">
            </div>
        </div>

        <!-- Incluir Leaflet JS -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
        <script>
            // Elementos del DOM
            const startBtn = document.getElementById("startBtn");
            const stopBtn = document.getElementById("stopBtn");
            const clearBtn = document.getElementById("clearBtn");
            const downloadBtn = document.getElementById("downloadBtn");
            const intervalInput = document.getElementById("intervalInput");
            const status = document.getElementById("status");
            const coordinates = document.getElementById("coordinates");
            const statusIndicator = document.querySelector(".status-indicator");
            const statusInfo = document.querySelector(".status-info");

            // Variables de control
            let trackingInterval;
            let entriesCount = 0;
            let coordinatesData = [];
            let isTracking = false;
            let trackingWorker = null;
            let lastPositionTime = 0;
            
            // Nombre del almacenamiento para guardar datos
            const STORAGE_KEY = "geoTrackerData";
            
            // Comprobar soporte para APIs necesarias
            const hasServiceWorkerSupport = 'serviceWorker' in navigator;
            const hasWakeLockSupport = 'wakeLock' in navigator;
            let wakeLock = null;

            // Inicializar el mapa de Leaflet
            let map = L.map("map").setView([0, 0], 2);
            let routeLine = L.polyline([], { color: "#292929", weight: 4 });
            let markersLayer = L.layerGroup();
            let firstLoad = true;

            // Añadir la capa de OpenStreetMap
            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            }).addTo(map);

            // Crear leyenda
            let legend = L.control({ position: "topright" });
            legend.onAdd = function (map) {
                let div = L.DomUtil.create("div", "legend");
                div.innerHTML = `
                <div><i style="background: #858585"></i> Puntos anteriores<br></div>
                <div><i style="background: #292929"></i> Punto actual<br></div>
                <div><i style="background: #292929; height: 4px; width: 14px; border-radius: 0"></i> Recorrido</div>
            `;
                return div;
            };
            legend.addTo(map);

            // Cargar datos guardados al iniciar y verificar si había un seguimiento activo
            window.onload = function () {
                loadSavedData();
                updateMap();
                
                // Comprobar si hay un seguimiento activo desde una sesión anterior
                const wasTracking = localStorage.getItem('trackingActive') === 'true';
                if (wasTracking) {
                    const interval = parseInt(localStorage.getItem('trackingInterval') || '20');
                    intervalInput.value = interval;
                    
                    // Informar al usuario
                    status.innerHTML = "<p>Recuperando seguimiento de sesión anterior...</p>";
                    
                    // Iniciar el seguimiento nuevamente
                    setTimeout(() => {
                        startTracking();
                    }, 1000);
                }
                
                // Inicializar indicador de estado
                updateTrackingStatus('good');
            };

            // Actualizar indicador de estado de seguimiento
            function updateTrackingStatus(status = 'good', message = '') {
                // Eliminar clases existentes
                statusIndicator.classList.remove('status-good', 'status-warning', 'status-error');
                
                // Determinar mensaje según el estado
                let statusText = '';
                
                // Añadir la clase apropiada según el estado
                if (status === 'good') {
                    statusIndicator.classList.add('status-good');
                    statusText = message || 'Seguimiento funcionando correctamente';
                } else if (status === 'warning') {
                    statusIndicator.classList.add('status-warning');
                    statusText = message || 'Seguimiento funcionando con dificultades';
                } else if (status === 'error') {
                    statusIndicator.classList.add('status-error');
                    statusText = message || 'Error en el seguimiento';
                }
                
                // Actualizar contenido del div de información
                statusInfo.innerHTML = statusText;
                // Mantener atributo title para navegadores de escritorio
                statusIndicator.title = statusText;
            }
            
            // Manejar clic en el indicador de estado
            statusIndicator.addEventListener('click', function(e) {
                e.stopPropagation(); // Evitar que el clic llegue al mapa
                statusInfo.style.display = statusInfo.style.display === 'block' ? 'none' : 'block';
            });
            
            // Cerrar el panel informativo al hacer clic en cualquier otra parte
            document.addEventListener('click', function(e) {
                if (e.target !== statusIndicator && e.target !== statusInfo) {
                    statusInfo.style.display = 'none';
                }
            });

            // Función para obtener la ubicación actual
            function getCurrentPosition() {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        // Si se obtiene correctamente
                        (position) => {
                            const latitude = position.coords.latitude;
                            const longitude = position.coords.longitude;
                            const accuracy = position.coords.accuracy || 0;
                            const timestamp = new Date();
                            
                            // Actualizar la hora de última posición
                            lastPositionTime = Date.now();
                            localStorage.setItem('trackingLastCheck', lastPositionTime.toString());

                            // Guardar datos para GeoJSON
                            const pointData = {
                                id: ++entriesCount,
                                timestamp: timestamp.toISOString(),
                                coords: {
                                    latitude: latitude,
                                    longitude: longitude,
                                    accuracy: accuracy
                                }
                            };
                            coordinatesData.push(pointData);

                            // Crear entrada de coordenadas
                            const entry = document.createElement("div");
                            entry.className = "coordinate-entry";
                            entry.innerHTML = `
                            <strong>${entriesCount}. ${timestamp.toLocaleTimeString()}</strong><br>
                            Lat: ${latitude}<br>
                            Long: ${longitude}
                        `;

                            // Si hay contenido inicial y es el primer elemento, eliminarlo
                            if (entriesCount === 1 && coordinates.firstChild && coordinates.firstChild.tagName === "P") {
                                coordinates.innerHTML = "";
                            }

                            // Agregar la nueva entrada al principio
                            coordinates.insertBefore(entry, coordinates.firstChild);

                            // Actualizar el mapa con las nuevas coordenadas
                            updateMap();

                            // Guardar datos en almacenamiento local
                            saveData();
                            
                            // Actualizar indicador a estado correcto
                            updateTrackingStatus('good');
                        },
                        // Si hay un error
                        (error) => {
                            const errorMsg = document.createElement("div");
                            errorMsg.className = "error";

                            switch (error.code) {
                                case error.PERMISSION_DENIED:
                                    errorMsg.textContent = "Usuario denegó la solicitud de geolocalización.";
                                    break;
                                case error.POSITION_UNAVAILABLE:
                                    errorMsg.textContent = "Información de ubicación no disponible.";
                                    break;
                                case error.TIMEOUT:
                                    errorMsg.textContent = "Tiempo de espera agotado para obtener ubicación.";
                                    break;
                                case error.UNKNOWN_ERROR:
                                    errorMsg.textContent = "Error desconocido.";
                                    break;
                            }

                            status.innerHTML = "";
                            status.appendChild(errorMsg);
                            
                            // Actualizar indicador a estado de error
                            updateTrackingStatus('error', 'No se pudo obtener la ubicación: ' + errorMsg.textContent);
                        }
                    );
                } else {
                    status.innerHTML = "<div class='error'>La geolocalización no es compatible con este navegador.</div>";
                    updateTrackingStatus('error', 'La geolocalización no es compatible con este navegador');
                    stopTracking();
                }
            }

            // Función para solicitar WakeLock (mantener pantalla activa)
            async function requestWakeLock() {
                if (!hasWakeLockSupport) return;
                
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => {
                        console.log('WakeLock fue liberado');
                        // Intentar adquirirlo nuevamente si seguimos en seguimiento
                        if (isTracking) {
                            requestWakeLock();
                        }
                    });
                    console.log('WakeLock activado');
                } catch (err) {
                    console.error(`No se pudo obtener WakeLock: ${err.name}, ${err.message}`);
                }
            }
            
            // Función para manejar cambios de visibilidad de la página
            function handleVisibilityChange() {
                if (document.visibilityState === 'visible' && isTracking) {
                    // La página volvió a ser visible
                    console.log('Página visible de nuevo, verificando posiciones perdidas');
                    
                    const lastCheck = parseInt(localStorage.getItem('trackingLastCheck') || '0');
                    const interval = parseInt(localStorage.getItem('trackingInterval') || '20');
                    const now = Date.now();
                    
                    // Si han pasado más de dos intervalos desde la última verificación
                    if (now - lastCheck > interval * 2000) {
                        console.log('Recuperando posición después de inactividad');
                        getCurrentPosition();
                        
                        // Mostrar advertencia de posibles problemas
                        updateTrackingStatus('warning', 'Han pasado ' + Math.round((now - lastCheck)/1000) + 's sin actualizar la posición. Recuperando...');
                    }
                    
                    // Actualizar la hora del último chequeo
                    localStorage.setItem('trackingLastCheck', now.toString());
                    
                    // Reactivar el WakeLock si es necesario
                    if (hasWakeLockSupport && !wakeLock) {
                        requestWakeLock();
                    }
                }
            }
            
            // Configurar seguimiento en segundo plano
            function setupBackgroundTracking(interval) {
                // Verificar si el navegador soporta trabajadores en segundo plano
                if (window.Worker) {
                    try {
                        // Crear un Blob con el código del worker
                        const workerCode = `
                            let trackingInterval;
                            
                            self.onmessage = function(e) {
                                if (e.data.command === 'start') {
                                    const interval = e.data.interval;
                                    trackingInterval = setInterval(() => {
                                        self.postMessage({type: 'requestPosition'});
                                    }, interval * 1000);
                                    console.log('Worker iniciado con intervalo: ' + interval + 's');
                                } else if (e.data.command === 'stop') {
                                    clearInterval(trackingInterval);
                                    console.log('Worker detenido');
                                    self.close();
                                }
                            };
                        `;
                        
                        // Crear una URL para el Blob
                        const workerBlob = new Blob([workerCode], {type: 'application/javascript'});
                        const workerUrl = URL.createObjectURL(workerBlob);
                        
                        // Crear el worker
                        trackingWorker = new Worker(workerUrl);
                        
                        // Configurar el listener para mensajes del worker
                        trackingWorker.onmessage = function(e) {
                            if (e.data.type === 'requestPosition') {
                                // El worker solicita una actualización de posición
                                getCurrentPosition();
                            } else if (e.data.type === 'error') {
                                // Manejar errores reportados por el worker
                                console.error('Error en worker de seguimiento:', e.data.message);
                                updateTrackingStatus('warning', 'Error al iniciar el seguimiento en segundo plano: ' + err.message);
                            }
                        };
                        
                        // Iniciar el worker
                        trackingWorker.postMessage({
                            command: 'start',
                            interval: interval
                        });
                        
                        console.log('Worker de seguimiento iniciado');
                    } catch (err) {
                        console.error('Error al iniciar worker: ', err);
                        updateTrackingStatus('warning');
                    }
                }
            }

            // Función para iniciar el seguimiento
            function startTracking() {
                // Comprobar si el navegador soporta geolocalización
                if (!navigator.geolocation) {
                    status.innerHTML = "<div class='error'>La geolocalización no es compatible con este navegador.</div>";
                    return;
                }

                // Obtener intervalo de actualización
                const interval = parseInt(intervalInput.value) || 20;
                if (interval < 1 || interval > 120) {
                    status.innerHTML = "<div class='error'>El intervalo debe estar entre 1 y 120 segundos.</div>";
                    return;
                }

                // Cambiar estado de botones
                startBtn.disabled = true;
                stopBtn.disabled = false;
                clearBtn.disabled = true;
                downloadBtn.disabled = true;
                intervalInput.disabled = true;
                isTracking = true;

                // Mostrar mensaje de estado
                status.innerHTML = `<p>Seguimiento activo (cada ${interval} segundos)...</p>`;
                
                // Actualizar indicador de estado
                updateTrackingStatus('good');
                
                // Solicitar WakeLock para mantener la pantalla activa (si está disponible)
                if (hasWakeLockSupport) {
                    requestWakeLock();
                }
                
                // Registrar para notificaciones en segundo plano (si está disponible)
                if (hasServiceWorkerSupport && 'Notification' in window) {
                    Notification.requestPermission();
                }
                
                // Obtener posición inicial
                getCurrentPosition();
                
                // Usar localStorage para almacenar la hora de inicio y el intervalo
                localStorage.setItem('trackingActive', 'true');
                localStorage.setItem('trackingInterval', interval.toString());
                localStorage.setItem('trackingLastCheck', Date.now().toString());
                
                // Crear un worker para seguimiento en segundo plano
                setupBackgroundTracking(interval);
                
                // Configurar intervalo para obtener posición (como respaldo)
                trackingInterval = setInterval(getCurrentPosition, interval * 1000);
                
                // Configurar evento de visibilidad para detectar cuando la página vuelve a estar visible
                document.addEventListener('visibilitychange', handleVisibilityChange);
                
                // Registrar evento para cuando la aplicación se cierra
                window.addEventListener('beforeunload', function() {
                    if (isTracking) {
                        localStorage.setItem('trackingActive', 'true');
                        localStorage.setItem('trackingLastCheck', Date.now().toString());
                    }
                });
            }

            // Función para detener el seguimiento
            function stopTracking() {
                // Detener intervalo
                clearInterval(trackingInterval);

                // Cambiar estado de botones
                startBtn.disabled = false;
                stopBtn.disabled = true;
                clearBtn.disabled = false;
                downloadBtn.disabled = false;
                intervalInput.disabled = false;
                isTracking = false;

                // Mostrar mensaje de estado
                status.innerHTML = "<p>Seguimiento detenido.</p>";
                
                // Actualizar indicador a estado neutral
                updateTrackingStatus('good');
                
                // Liberar WakeLock si existe
                if (wakeLock) {
                    wakeLock.release()
                        .then(() => {
                            wakeLock = null;
                            console.log('WakeLock liberado');
                        });
                }
                
                // Detener el worker si existe
                if (trackingWorker) {
                    trackingWorker.postMessage({command: 'stop'});
                    trackingWorker = null;
                }
                
                // Eliminar marcadores de seguimiento en localStorage
                localStorage.removeItem('trackingActive');
                localStorage.removeItem('trackingInterval');
                localStorage.removeItem('trackingLastCheck');
                
                // Eliminar event listeners
                document.removeEventListener('visibilitychange', handleVisibilityChange);
            }

            // Función para borrar todos los registros
            function clearData() {
                coordinates.innerHTML = "";
                entriesCount = 0;
                coordinatesData = [];
                saveData();
                status.innerHTML = "<p>Todos los registros han sido borrados.</p>";

                // Limpiar el mapa
                markersLayer.clearLayers();
                routeLine.setLatLngs([]);
                map.addLayer(routeLine);
                map.setView([0, 0], 2);
            }

            // Función para descargar datos en formato GeoJSON
            function downloadGeoJSON() {
                if (coordinatesData.length === 0) {
                    status.innerHTML = "<div class='error'>No hay datos para descargar.</div>";
                    return;
                }

                // Crear objeto GeoJSON con la polilínea como elemento principal
                const geoJSON = {
                    type: "FeatureCollection",
                    features: [
                        // LineString para el recorrido completo (polilínea principal)
                        {
                            type: "Feature",
                            properties: {
                                name: "Recorrido completo",
                                description: "Trayecto registrado con aplicación de seguimiento GPS",
                                startTime: coordinatesData[0].timestamp,
                                endTime: coordinatesData[coordinatesData.length - 1].timestamp,
                                pointsCount: coordinatesData.length,
                            },
                            geometry: {
                                type: "LineString",
                                coordinates: coordinatesData.map((p) => [p.coords.longitude, p.coords.latitude]),
                            },
                        },
                    ],
                };

                // Crear archivo para descargar
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(geoJSON, null, 2));
                const downloadAnchor = document.createElement("a");
                downloadAnchor.setAttribute("href", dataStr);
                downloadAnchor.setAttribute("download", `geo_tracking_${new Date().toISOString().slice(0, 10)}.geojson`);
                document.body.appendChild(downloadAnchor);
                downloadAnchor.click();
                downloadAnchor.remove();

                status.innerHTML = "<p>Archivo GeoJSON descargado.</p>";
            }

            // Función para guardar datos en localStorage
            function saveData() {
                try {
                    localStorage.setItem(
                        STORAGE_KEY,
                        JSON.stringify({
                            count: entriesCount,
                            data: coordinatesData,
                        })
                    );
                } catch (e) {
                    console.error("Error al guardar datos:", e);
                    status.innerHTML += "<div class='error'>No se pudieron guardar los datos localmente.</div>";
                }
            }

            // Función para cargar datos guardados
            function loadSavedData() {
                try {
                    const savedData = localStorage.getItem(STORAGE_KEY);
                    if (savedData) {
                        const parsedData = JSON.parse(savedData);
                        coordinatesData = parsedData.data || [];
                        entriesCount = parsedData.count || 0;

                        if (coordinatesData.length > 0) {
                            // Limpiar el contenedor
                            coordinates.innerHTML = "";

                            // Mostrar datos guardados
                            coordinatesData
                                .slice()
                                .reverse()
                                .forEach((point) => {
                                    const entry = document.createElement("div");
                                    entry.className = "coordinate-entry";
                                    const localTime = new Date(point.timestamp).toLocaleTimeString();
                                    entry.innerHTML = `
                                <strong>${point.id}. ${localTime}</strong><br>
                                Lat: ${point.coords.latitude}<br>
                                Long: ${point.coords.longitude}
                            `;
                                    coordinates.appendChild(entry);
                                });

                            status.innerHTML = `<p>Se cargaron ${coordinatesData.length} registros guardados.</p>`;
                        }
                    }
                } catch (e) {
                    console.error("Error al cargar datos:", e);
                    status.innerHTML = "<div class='error'>Error al cargar datos guardados.</div>";
                }
            }

            // Función para actualizar el mapa
            function updateMap() {
                // Limpiar las capas anteriores
                markersLayer.clearLayers();
                routeLine.setLatLngs([]);

                if (coordinatesData.length === 0) {
                    return;
                }

                // Crear array de puntos para la línea
                const routePoints = coordinatesData.map((point) => [point.coords.latitude, point.coords.longitude]);

                // Actualizar la línea de ruta
                routeLine.setLatLngs(routePoints);
                map.addLayer(routeLine);

                // Añadir marcadores para cada punto
                coordinatesData.forEach((point, index) => {
                    // Determinar si es el punto más reciente
                    const isLatestPoint = index === coordinatesData.length - 1;

                    // Color del marcador basado en si es el último punto o no
                    const markerColor = isLatestPoint ? "#292929" : "#858585";

                    // Crear marcador con círculo personalizado
                    const marker = L.circleMarker([point.coords.latitude, point.coords.longitude], {
                        radius: 8,
                        fillColor: markerColor,
                        color: "#000",
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8,
                    });

                    // Añadir información al marcador
                    const localTime = new Date(point.timestamp).toLocaleTimeString();
                    marker.bindPopup(`
                    <strong>Punto #${point.id}</strong><br>
                    Hora: ${localTime}<br>
                    Latitud: ${point.coords.latitude}<br>
                    Longitud: ${point.coords.longitude}<br>
                    ${point.coords.accuracy ? `Precisión: ${point.coords.accuracy} metros` : ''}
                `);

                    // Añadir etiqueta con el número del punto a la derecha
                    marker.bindTooltip(point.id.toString(), {
                        permanent: true,
                        direction: "right", // Colocar a la derecha
                        offset: [5, -5], // Ajustar posición (x, y)
                        className: "custom-tooltip", // Clase personalizada
                    });

                    // Añadir el marcador a la capa de marcadores
                    markersLayer.addLayer(marker);
                });

                // Añadir capa de marcadores al mapa
                map.addLayer(markersLayer);

                // Al cargar por primera vez o cuando hay nuevos datos, hacer zoom al recorrido
                if (firstLoad || coordinatesData.length <= 1) {
                    // Si solo hay un punto, hacer zoom a ese punto
                    if (coordinatesData.length === 1) {
                        const point = coordinatesData[0];
                        map.setView([point.coords.latitude, point.coords.longitude], 15);
                    } else {
                        // Si hay múltiples puntos, ajustar la vista para incluir todos
                        const bounds = L.latLngBounds(routePoints);
                        map.fitBounds(bounds, { padding: [50, 50] });
                    }
                    firstLoad = false;
                } else if (isTracking) {
                    // Para actualizaciones posteriores durante el seguimiento, centrar en el punto más reciente
                    const latestPoint = coordinatesData[coordinatesData.length - 1];
                    map.panTo([latestPoint.coords.latitude, latestPoint.coords.longitude]);
                }
            }

            // Asignar eventos a botones
            startBtn.addEventListener("click", startTracking);
            stopBtn.addEventListener("click", stopTracking);
            clearBtn.addEventListener("click", clearData);
            downloadBtn.addEventListener("click", downloadGeoJSON);

            // Actualizar tamaño del mapa cuando se redimensione la ventana
            window.addEventListener("resize", function () {
                map.invalidateSize();
            });
        </script>
    </body>
</html>